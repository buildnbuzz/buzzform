{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "select",
  "title": "SelectField",
  "description": "A select dropdown field component for BuzzForm. Supports single and multi-select (hasMany), static or async options, dependent dropdowns (dependencies), searchable, clearable, and custom option rendering with icons and descriptions.",
  "dependencies": [
    "@buildnbuzz/buzzform"
  ],
  "registryDependencies": [
    "@buzzform/init",
    "combobox",
    "input-group",
    "field"
  ],
  "files": [
    {
      "path": "registry/base/fields/select.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport type {\n  SelectField as SelectFieldType,\n  SelectOption,\n  FormAdapter,\n  ValidationContext,\n} from \"@buildnbuzz/buzzform\";\n\ninterface ExtendedSelectOption extends SelectOption {\n  badge?: string;\n}\n\nimport {\n  getNestedValue,\n  normalizeSelectOption,\n  getSelectOptionLabel,\n  getSelectOptionLabelString,\n  getFieldWidthStyle,\n} from \"@buildnbuzz/buzzform\";\nimport {\n  Field,\n  FieldContent,\n  FieldDescription,\n  FieldError,\n  FieldLabel,\n} from \"@/components/ui/field\";\nimport {\n  Combobox,\n  ComboboxInput,\n  ComboboxContent,\n  ComboboxList,\n  ComboboxItem,\n  ComboboxEmpty,\n  ComboboxChips,\n  ComboboxChip,\n  ComboboxChipsInput,\n  ComboboxTrigger,\n  ComboboxValue,\n  useComboboxAnchor,\n} from \"@/components/ui/combobox\";\nimport {\n  InputGroup,\n  InputGroupAddon,\n  InputGroupButton,\n} from \"@/components/ui/input-group\";\n\nimport { Combobox as ComboboxPrimitive } from \"@base-ui/react\";\nimport { cn } from \"@/lib/utils\";\nimport { IconPlaceholder } from \"@/components/icon-placeholder\";\n\nfunction ComboboxClear({ className, ...props }: ComboboxPrimitive.Clear.Props) {\n  return (\n    <ComboboxPrimitive.Clear\n      data-slot=\"combobox-clear\"\n      render={<InputGroupButton variant=\"ghost\" size=\"icon-xs\" />}\n      className={cn(\"cn-combobox-clear\", className)}\n      {...props}\n    >\n      <IconPlaceholder\n        lucide=\"XIcon\"\n        tabler=\"IconX\"\n        hugeicons=\"Cancel01Icon\"\n        phosphor=\"XIcon\"\n        remixicon=\"RiCloseLine\"\n        className=\"cn-combobox-clear-icon pointer-events-none\"\n      />\n    </ComboboxPrimitive.Clear>\n  );\n}\nexport interface SelectFieldProps {\n  field: SelectFieldType;\n  path: string;\n  form: FormAdapter;\n  autoFocus?: boolean;\n  formValues: Record<string, unknown>;\n  siblingData: Record<string, unknown>;\n  // Computed props\n  fieldId: string;\n  label: React.ReactNode | null;\n  isDisabled: boolean;\n  isReadOnly: boolean;\n  error?: string;\n}\n\ntype OptionValue = string | number | boolean;\n\n/** Convert option values to string for comparison */\nfunction valueToString(value: OptionValue): string {\n  if (typeof value === \"boolean\") return value ? \"true\" : \"false\";\n  return String(value);\n}\n\nfunction stringToValue(\n  str: string,\n  options: SelectOption[],\n): OptionValue | undefined {\n  const option = options.find((opt) => valueToString(opt.value) === str);\n  return option?.value;\n}\n\nfunction isAsyncOptions(\n  options: SelectFieldType[\"options\"],\n): options is (context: ValidationContext) => Promise<SelectOption[]> {\n  return typeof options === \"function\";\n}\n\nfunction useAsyncOptions(\n  options: SelectFieldType[\"options\"],\n  dependencies: string[] | undefined,\n  formValues: Record<string, unknown>,\n  siblingData: Record<string, unknown>,\n  path: string,\n): {\n  resolvedOptions: SelectOption[];\n  isLoading: boolean;\n} {\n  const isAsync = isAsyncOptions(options);\n  const cacheRef = useRef<Map<string, SelectOption[]>>(new Map());\n\n  const [resolvedOptions, setResolvedOptions] = useState<SelectOption[]>(\n    !isAsync\n      ? Array.isArray(options)\n        ? options.map(normalizeSelectOption)\n        : []\n      : [],\n  );\n  const [isLoading, setIsLoading] = useState(isAsync);\n\n  const dependencyKey = (() => {\n    if (!dependencies || dependencies.length === 0) return \"static\";\n    const values = dependencies.map((dep) => getNestedValue(formValues, dep));\n    return JSON.stringify(values);\n  })();\n\n  useEffect(() => {\n    if (!isAsync) {\n      if (Array.isArray(options)) {\n        setResolvedOptions(options.map(normalizeSelectOption));\n      }\n      setIsLoading(false);\n      return;\n    }\n\n    if (cacheRef.current.has(dependencyKey)) {\n      setResolvedOptions(cacheRef.current.get(dependencyKey)!);\n      setIsLoading(false);\n      return;\n    }\n\n    let isMounted = true;\n\n    async function fetchOptions() {\n      setIsLoading(true);\n\n      try {\n        const context: ValidationContext = {\n          data: formValues,\n          siblingData,\n          path: path.split(\".\"),\n        };\n\n        const result = await (\n          options as (context: ValidationContext) => Promise<SelectOption[]>\n        )(context);\n\n        const normalized = result.map(normalizeSelectOption);\n\n        if (isMounted) {\n          cacheRef.current.set(dependencyKey, normalized);\n          setResolvedOptions(normalized);\n        }\n      } catch (err) {\n        console.error(\"Failed to fetch select options:\", err);\n        if (isMounted) {\n          setResolvedOptions([]);\n        }\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    }\n\n    fetchOptions();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [isAsync, options, dependencyKey, formValues, siblingData, path]);\n\n  return { resolvedOptions, isLoading };\n}\n\nexport function SelectField({\n  field,\n  path,\n  form,\n  autoFocus,\n  formValues,\n  siblingData,\n  fieldId,\n  label,\n  isDisabled,\n  isReadOnly,\n  error,\n}: SelectFieldProps) {\n  const [searchValue, setSearchValue] = useState(\"\");\n  const rawValue = form.watch(path);\n  const anchorRef = useComboboxAnchor();\n  const hasError = !!error;\n\n  const { resolvedOptions, isLoading } = useAsyncOptions(\n    field.options,\n    field.dependencies,\n    formValues,\n    siblingData,\n    path,\n  );\n\n  const isSearchable = field.ui?.isSearchable !== false;\n  const isClearable = field.ui?.isClearable ?? !field.required;\n  const maxVisibleChips = field.ui?.maxVisibleChips ?? 3;\n  const maxSelected = field.hasMany ? field.maxSelected : undefined;\n  const emptyMessage = field.ui?.emptyMessage ?? \"No results found\";\n  const loadingMessage = field.ui?.loadingMessage ?? \"Loading...\";\n  const placeholder =\n    field.placeholder ??\n    (field.hasMany ? \"Select options...\" : \"Select an option...\");\n  const searchPlaceholder = \"Search...\";\n\n  const filteredOptions = (() => {\n    if (!isSearchable || !searchValue.trim()) {\n      return resolvedOptions;\n    }\n    const query = searchValue.toLowerCase();\n    return resolvedOptions.filter((opt) =>\n      getSelectOptionLabelString(opt).toLowerCase().includes(query),\n    );\n  })();\n\n  const handleSingleChange = (stringValue: string | null) => {\n    if (stringValue === null) {\n      form.setValue(path, undefined, {\n        shouldDirty: true,\n        shouldValidate: true,\n      });\n      return;\n    }\n    const actualValue = stringToValue(stringValue, resolvedOptions);\n    form.setValue(path, actualValue, {\n      shouldDirty: true,\n      shouldValidate: true,\n    });\n    setSearchValue(\"\");\n  };\n\n  const handleMultiChange = (stringValues: string[]) => {\n    const actualValues = stringValues\n      .map((sv) => stringToValue(sv, resolvedOptions))\n      .filter((v): v is OptionValue => v !== undefined);\n\n    const hasMaxLimit = typeof maxSelected === \"number\" && maxSelected >= 0;\n    const isGrowingSelection = actualValues.length > multiValues.length;\n    if (\n      hasMaxLimit &&\n      isGrowingSelection &&\n      actualValues.length > maxSelected\n    ) {\n      return;\n    }\n\n    form.setValue(path, actualValues, {\n      shouldDirty: true,\n      shouldValidate: true,\n    });\n  };\n\n  const singleValue =\n    rawValue === undefined || rawValue === null\n      ? null\n      : valueToString(rawValue as OptionValue);\n\n  const multiValues = !Array.isArray(rawValue)\n    ? []\n    : (rawValue as OptionValue[]).map(valueToString);\n  const hasMaxLimit = typeof maxSelected === \"number\" && maxSelected >= 0;\n  const isAtMaxSelection = hasMaxLimit && multiValues.length >= maxSelected;\n\n  const selectedOption = resolvedOptions.find(\n    (o) => singleValue !== null && valueToString(o.value) === singleValue,\n  );\n\n  const renderOptionContent = (option: ExtendedSelectOption) => (\n    <div className=\"flex items-center gap-2 flex-1 min-w-0\">\n      {option.icon && (\n        <span className=\"shrink-0 text-muted-foreground\">{option.icon}</span>\n      )}\n      <div className=\"flex-1 min-w-0 py-0.5 text-left\">\n        <div className=\"flex items-center gap-2\">\n          <span className=\"truncate font-medium\">\n            {getSelectOptionLabel(option)}\n          </span>\n          {option.badge && (\n            <span className=\"shrink-0 px-1.5 py-0.5 rounded-full bg-primary/10 text-primary text-[10px] font-bold uppercase tracking-wider\">\n              {option.badge}\n            </span>\n          )}\n        </div>\n        {option.description && (\n          <div className=\"text-xs text-muted-foreground truncate mt-0.5\">\n            {option.description}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n\n  const renderMultiSelect = () => {\n    const visibleChips = multiValues.slice(0, maxVisibleChips);\n    const hiddenCount = multiValues.length - maxVisibleChips;\n\n    return (\n      <Combobox\n        multiple\n        value={multiValues}\n        onValueChange={handleMultiChange}\n        inputValue={searchValue}\n        onInputValueChange={setSearchValue}\n        disabled={isDisabled || isReadOnly}\n      >\n        <div ref={anchorRef} className=\"w-full\">\n          <ComboboxChips className=\"min-h-8 w-full px-2\">\n            {visibleChips.map((val, index) => {\n              const opt = resolvedOptions.find(\n                (o) => valueToString(o.value) === val,\n              );\n              return (\n                <ComboboxChip key={`${val}-${index}`}>\n                  {opt ? getSelectOptionLabelString(opt) : val}\n                </ComboboxChip>\n              );\n            })}\n            {hiddenCount > 0 && (\n              <div className=\"bg-muted/50 text-muted-foreground flex h-6 items-center justify-center rounded-sm px-1.5 text-[10px] font-bold whitespace-nowrap\">\n                +{hiddenCount}\n              </div>\n            )}\n            {isSearchable && (\n              <ComboboxChipsInput\n                id={fieldId}\n                placeholder={multiValues.length === 0 ? placeholder : \"\"}\n                autoFocus={autoFocus}\n                className=\"py-1\"\n              />\n            )}\n            {!isSearchable && multiValues.length === 0 && (\n              <ComboboxTrigger className=\"flex-1 text-left py-1 text-muted-foreground h-8 px-3\">\n                {placeholder}\n              </ComboboxTrigger>\n            )}\n          </ComboboxChips>\n        </div>\n        <ComboboxContent anchor={anchorRef} className=\"w-(--anchor-width)\">\n          <ComboboxList className=\"p-1.5\">\n            {isLoading ? (\n              <div className=\"py-6 text-center text-sm text-muted-foreground\">\n                {loadingMessage}\n              </div>\n            ) : (\n              <>\n                {filteredOptions.length === 0 && (\n                  <ComboboxEmpty className=\"py-6\">{emptyMessage}</ComboboxEmpty>\n                )}\n                {filteredOptions.map((option, i) => (\n                  <ComboboxItem\n                    key={`${valueToString(option.value)}-${i}`}\n                    value={valueToString(option.value)}\n                    disabled={\n                      option.disabled ||\n                      (isAtMaxSelection &&\n                        !multiValues.includes(valueToString(option.value)))\n                    }\n                    className=\"py-2 px-2.5\"\n                  >\n                    {renderOptionContent(option)}\n                  </ComboboxItem>\n                ))}\n              </>\n            )}\n          </ComboboxList>\n        </ComboboxContent>\n      </Combobox>\n    );\n  };\n\n  const renderSingleSelect = () => (\n    <Combobox\n      value={singleValue}\n      onValueChange={handleSingleChange}\n      inputValue={searchValue}\n      onInputValueChange={setSearchValue}\n      disabled={isDisabled || isReadOnly}\n    >\n      <div ref={anchorRef} className=\"w-full\">\n        <InputGroup className=\"w-full\">\n          <InputGroupButton\n            id={fieldId}\n            render={<ComboboxTrigger />}\n            className=\"flex-1 justify-between font-normal h-8 px-3\"\n            disabled={isDisabled || isReadOnly}\n          >\n            {selectedOption ? (\n              <span className=\"flex items-center gap-2 truncate text-left\">\n                {selectedOption.icon && (\n                  <span className=\"shrink-0 text-muted-foreground\">\n                    {selectedOption.icon}\n                  </span>\n                )}\n                <span className=\"truncate\">\n                  {getSelectOptionLabelString(selectedOption)}\n                </span>\n              </span>\n            ) : (\n              <ComboboxValue>\n                {(value) =>\n                  value ?? (\n                    <span className=\"text-muted-foreground\">{placeholder}</span>\n                  )\n                }\n              </ComboboxValue>\n            )}\n          </InputGroupButton>\n          {isClearable && singleValue !== null && (\n            <InputGroupAddon align=\"inline-end\">\n              <ComboboxClear disabled={isDisabled || isReadOnly} />\n            </InputGroupAddon>\n          )}\n        </InputGroup>\n      </div>\n\n      <ComboboxContent anchor={anchorRef} className=\"w-(--anchor-width)\">\n        {isSearchable && (\n          <div className=\"p-1 border-b\">\n            <ComboboxInput\n              autoFocus\n              placeholder={searchPlaceholder}\n              className=\"w-full border-none shadow-none focus-visible:ring-0 h-8\"\n              showTrigger={false}\n            />\n          </div>\n        )}\n        <ComboboxList className=\"p-1.5\">\n          {isLoading ? (\n            <div className=\"py-6 text-center text-sm text-muted-foreground\">\n              {loadingMessage}\n            </div>\n          ) : (\n            <>\n              {filteredOptions.length === 0 && (\n                <ComboboxEmpty className=\"py-6\">{emptyMessage}</ComboboxEmpty>\n              )}\n              {filteredOptions.map((option, i) => (\n                <ComboboxItem\n                  key={`${valueToString(option.value)}-${i}`}\n                  value={valueToString(option.value)}\n                  disabled={option.disabled}\n                  className=\"py-2 px-2.5\"\n                >\n                  {renderOptionContent(option)}\n                </ComboboxItem>\n              ))}\n            </>\n          )}\n        </ComboboxList>\n      </ComboboxContent>\n    </Combobox>\n  );\n\n  return (\n    <Field\n      className={field.style?.className}\n      data-invalid={hasError}\n      data-disabled={isDisabled}\n      style={getFieldWidthStyle(field.style)}\n    >\n      {label && (\n        <FieldLabel htmlFor={fieldId} className=\"gap-1 items-baseline\">\n          {label}\n          {field.required && <span className=\"text-destructive\">*</span>}\n        </FieldLabel>\n      )}\n\n      <FieldContent>\n        {field.hasMany ? renderMultiSelect() : renderSingleSelect()}\n      </FieldContent>\n\n      {field.description && (\n        <FieldDescription id={`${fieldId}-description`}>\n          {field.description}\n        </FieldDescription>\n      )}\n\n      {error && <FieldError>{error}</FieldError>}\n    </Field>\n  );\n}\n\nexport function SelectFieldSkeleton({ field }: { field: SelectFieldType }) {\n  const label = field.label !== false ? (field.label ?? field.name) : null;\n\n  return (\n    <Field\n      className={field.style?.className}\n      style={\n        field.style?.width\n          ? {\n              width:\n                typeof field.style.width === \"number\"\n                  ? `${field.style.width}px`\n                  : field.style.width,\n            }\n          : undefined\n      }\n    >\n      {label && <div className=\"h-4 w-24 animate-pulse rounded bg-muted\" />}\n      <FieldContent>\n        <div className=\"h-8 w-full animate-pulse rounded-lg bg-muted\" />\n      </FieldContent>\n      {field.description && (\n        <div className=\"h-3 w-48 animate-pulse rounded bg-muted\" />\n      )}\n    </Field>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/buzzform/fields/select.tsx"
    }
  ],
  "type": "registry:ui"
}