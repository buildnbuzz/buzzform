{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "checkbox-group",
  "title": "CheckboxGroupField",
  "description": "A checkbox group field component for BuzzForm. Supports multi-select arrays, static or async options, min/max selected constraints, and default/card variants.",
  "dependencies": [
    "@buildnbuzz/buzzform"
  ],
  "registryDependencies": [
    "@buzzform/init",
    "checkbox",
    "field"
  ],
  "files": [
    {
      "path": "registry/base/fields/checkbox-group.tsx",
      "content": "\"use client\";\n\nimport { useEffect, useRef, useState } from \"react\";\nimport type {\n  CheckboxGroupField as CheckboxGroupFieldType,\n  SelectOption,\n  ValidationContext,\n  FormAdapter,\n} from \"@buildnbuzz/buzzform\";\nimport {\n  normalizeSelectOption,\n  getSelectOptionValue,\n  getSelectOptionLabel,\n  isSelectOptionDisabled,\n  getFieldWidthStyle,\n  getNestedValue,\n} from \"@buildnbuzz/buzzform\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport {\n  Field,\n  FieldDescription,\n  FieldError,\n  FieldLabel,\n} from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\n\ntype OptionValue = string | number | boolean;\n\nexport interface CheckboxGroupFieldProps {\n  field: CheckboxGroupFieldType;\n  path: string;\n  form: FormAdapter;\n  autoFocus?: boolean;\n  formValues: Record<string, unknown>;\n  siblingData: Record<string, unknown>;\n  // Computed props\n  fieldId: string;\n  label: React.ReactNode | null;\n  isDisabled: boolean;\n  isReadOnly: boolean;\n  error?: string;\n}\n\nfunction valueToString(value: OptionValue): string {\n  if (typeof value === \"boolean\") return value ? \"true\" : \"false\";\n  return String(value);\n}\n\nfunction stringToValue(\n  str: string,\n  options: SelectOption[],\n): OptionValue | undefined {\n  const option = options.find((opt) => valueToString(opt.value) === str);\n  return option?.value;\n}\n\nfunction isAsyncOptions(\n  options: CheckboxGroupFieldType[\"options\"],\n): options is (context: ValidationContext) => Promise<SelectOption[]> {\n  return typeof options === \"function\";\n}\n\nfunction useAsyncOptions(\n  options: CheckboxGroupFieldType[\"options\"],\n  dependencies: string[] | undefined,\n  formValues: Record<string, unknown>,\n  siblingData: Record<string, unknown>,\n  path: string,\n): {\n  resolvedOptions: SelectOption[];\n  isLoading: boolean;\n} {\n  const isAsync = isAsyncOptions(options);\n  const cacheRef = useRef<Map<string, SelectOption[]>>(new Map());\n\n  const [resolvedOptions, setResolvedOptions] = useState<SelectOption[]>(\n    !isAsync\n      ? Array.isArray(options)\n        ? options.map(normalizeSelectOption)\n        : []\n      : [],\n  );\n  const [isLoading, setIsLoading] = useState(isAsync);\n\n  const dependencyKey = (() => {\n    if (!dependencies || dependencies.length === 0) return \"static\";\n    const values = dependencies.map((dep) => getNestedValue(formValues, dep));\n    return JSON.stringify(values);\n  })();\n\n  useEffect(() => {\n    if (!isAsync) {\n      if (Array.isArray(options)) {\n        setResolvedOptions(options.map(normalizeSelectOption));\n      }\n      setIsLoading(false);\n      return;\n    }\n\n    if (cacheRef.current.has(dependencyKey)) {\n      setResolvedOptions(cacheRef.current.get(dependencyKey)!);\n      setIsLoading(false);\n      return;\n    }\n\n    let isMounted = true;\n\n    async function fetchOptions() {\n      setIsLoading(true);\n\n      try {\n        const context: ValidationContext = {\n          data: formValues,\n          siblingData,\n          path: path.split(\".\"),\n        };\n\n        const result = await (\n          options as (context: ValidationContext) => Promise<SelectOption[]>\n        )(context);\n\n        const normalized = result.map(normalizeSelectOption);\n\n        if (isMounted) {\n          cacheRef.current.set(dependencyKey, normalized);\n          setResolvedOptions(normalized);\n        }\n      } catch (err) {\n        console.error(\"Failed to fetch checkbox-group options:\", err);\n        if (isMounted) {\n          setResolvedOptions([]);\n        }\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    }\n\n    fetchOptions();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [isAsync, options, dependencyKey, formValues, siblingData, path]);\n\n  return { resolvedOptions, isLoading };\n}\n\nconst cardSizeClasses = {\n  sm: \"p-2.5 sm:p-3\",\n  md: \"p-3 sm:p-4\",\n  lg: \"p-4 sm:p-5\",\n} as const;\n\nexport function CheckboxGroupField({\n  field,\n  path,\n  form,\n  autoFocus,\n  formValues,\n  siblingData,\n  fieldId,\n  label,\n  isDisabled,\n  isReadOnly,\n  error,\n}: CheckboxGroupFieldProps) {\n  const rawValue = form.watch(path);\n  const hasError = !!error;\n\n  const selectedValues = Array.isArray(rawValue)\n    ? (rawValue as OptionValue[]).map(valueToString)\n    : [];\n\n  const { resolvedOptions, isLoading } = useAsyncOptions(\n    field.options,\n    field.dependencies,\n    formValues,\n    siblingData,\n    path,\n  );\n\n  const variant = field.ui?.variant ?? \"default\";\n  const direction = field.ui?.direction ?? \"vertical\";\n  const columns = field.ui?.columns ?? 1;\n  const cardSize = field.ui?.card?.size ?? \"md\";\n  const cardBordered = field.ui?.card?.bordered ?? true;\n  const maxSelected = field.maxSelected;\n\n  const isCardVariant = variant === \"card\";\n\n  const gridClasses = cn(\n    \"grid gap-2\",\n    direction === \"horizontal\" && columns === 1\n      ? \"grid-flow-col auto-cols-fr\"\n      : undefined,\n    columns === 2 && \"sm:grid-cols-2\",\n    columns === 3 && \"sm:grid-cols-2 md:grid-cols-3\",\n    columns === 4 && \"sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4\",\n  );\n\n  const handleToggle = (stringValue: string, checked: boolean) => {\n    if (isReadOnly) return;\n\n    const hasMaxLimit = typeof maxSelected === \"number\" && maxSelected >= 0;\n    if (checked && hasMaxLimit && selectedValues.length >= maxSelected) {\n      return;\n    }\n\n    const currentSet = new Set(selectedValues);\n    if (checked) {\n      currentSet.add(stringValue);\n    } else {\n      currentSet.delete(stringValue);\n    }\n\n    const nextValues = Array.from(currentSet)\n      .map((value) => stringToValue(value, resolvedOptions))\n      .filter((value): value is OptionValue => value !== undefined);\n\n    form.setValue(path, nextValues, {\n      shouldDirty: true,\n      shouldValidate: true,\n    });\n  };\n\n  return (\n    <div\n      className={cn(\"flex flex-col gap-2\", field.style?.className)}\n      data-invalid={hasError}\n      data-readonly={isReadOnly}\n      style={getFieldWidthStyle(field.style)}\n    >\n      {label && (\n        <FieldLabel className=\"gap-1 items-baseline\">\n          {field.required && <span className=\"text-destructive\">*</span>}\n          {label}\n        </FieldLabel>\n      )}\n\n      {field.description && (\n        <FieldDescription className=\"-mt-1 mb-1\" id={`${fieldId}-description`}>\n          {field.description}\n        </FieldDescription>\n      )}\n\n      <div\n        className={gridClasses}\n        role=\"group\"\n        aria-describedby={\n          field.description ? `${fieldId}-description` : undefined\n        }\n      >\n        {!isLoading &&\n          resolvedOptions.map((opt, i) => {\n            const value = getSelectOptionValue(opt);\n            const optionLabel = getSelectOptionLabel(opt);\n            const normalized = normalizeSelectOption(opt);\n            const checked = selectedValues.includes(value);\n            const hasMaxLimit =\n              typeof maxSelected === \"number\" && maxSelected >= 0;\n            const isAtMaxSelection =\n              hasMaxLimit && selectedValues.length >= maxSelected;\n            const optDisabled =\n              isSelectOptionDisabled(opt) ||\n              isDisabled ||\n              (isAtMaxSelection && !checked);\n            const id = `${fieldId}-${i}`;\n\n            if (isCardVariant) {\n              const showDescription =\n                normalized.description && cardSize !== \"sm\";\n              const optionKey = `${value}-${i}`;\n\n              return (\n                <label\n                  key={optionKey}\n                  htmlFor={id}\n                  className={cn(\n                    \"cursor-pointer transition-all duration-150 rounded-lg\",\n                    \"flex items-start gap-3\",\n                    cardSizeClasses[cardSize],\n                    cardBordered && \"border\",\n                    cardBordered &&\n                      checked &&\n                      \"border-primary ring-1 ring-primary/20 bg-primary/5 dark:bg-primary/10\",\n                    cardBordered &&\n                      !checked &&\n                      \"border-border hover:border-foreground/20 hover:bg-accent/30\",\n                    !cardBordered && \"hover:bg-accent/50\",\n                    !cardBordered && checked && \"bg-accent\",\n                    optDisabled &&\n                      \"opacity-50 cursor-not-allowed pointer-events-none\",\n                  )}\n                  data-checked={checked}\n                  data-disabled={optDisabled}\n                >\n                  <Checkbox\n                    id={id}\n                    checked={checked}\n                    onCheckedChange={(next) =>\n                      handleToggle(value, next === true)\n                    }\n                    disabled={optDisabled}\n                    className=\"shrink-0 mt-0.5\"\n                    autoFocus={autoFocus && i === 0}\n                  />\n                  <div className=\"flex flex-col gap-0.5 min-w-0 flex-1\">\n                    <div className=\"flex items-center gap-2\">\n                      {normalized.icon && (\n                        <span className=\"shrink-0 text-muted-foreground\">\n                          {normalized.icon}\n                        </span>\n                      )}\n                      <span\n                        className={cn(\n                          \"font-medium\",\n                          cardSize === \"lg\" ? \"text-base\" : \"text-sm\",\n                        )}\n                      >\n                        {optionLabel}\n                      </span>\n                    </div>\n                    {showDescription && (\n                      <span\n                        className={cn(\n                          \"text-muted-foreground line-clamp-2\",\n                          cardSize === \"lg\" ? \"text-sm\" : \"text-xs\",\n                        )}\n                      >\n                        {normalized.description}\n                      </span>\n                    )}\n                  </div>\n                </label>\n              );\n            }\n\n            return (\n              <Field\n                key={`${value}-${i}`}\n                orientation=\"horizontal\"\n                className={cn(\n                  \"items-center gap-2.5 space-y-0\",\n                  optDisabled && \"opacity-50 cursor-not-allowed\",\n                )}\n              >\n                <Checkbox\n                  id={id}\n                  checked={checked}\n                  onCheckedChange={(next) => handleToggle(value, next === true)}\n                  disabled={optDisabled}\n                  autoFocus={autoFocus && i === 0}\n                />\n                <FieldLabel\n                  htmlFor={id}\n                  className={cn(\n                    \"font-normal cursor-pointer m-0 flex items-center gap-2 text-sm\",\n                    optDisabled && \"cursor-not-allowed\",\n                  )}\n                >\n                  {normalized.icon && (\n                    <span className=\"shrink-0 text-muted-foreground\">\n                      {normalized.icon}\n                    </span>\n                  )}\n                  <span>{optionLabel}</span>\n                </FieldLabel>\n              </Field>\n            );\n          })}\n      </div>\n\n      {error && <FieldError>{error}</FieldError>}\n    </div>\n  );\n}\n\nexport function CheckboxGroupFieldSkeleton({\n  field,\n}: {\n  field: CheckboxGroupFieldType;\n}) {\n  const label = field.label !== false ? (field.label ?? field.name) : null;\n  const variant = field.ui?.variant ?? \"default\";\n  const direction = field.ui?.direction ?? \"vertical\";\n  const columns = field.ui?.columns ?? 1;\n  const cardSize = field.ui?.card?.size ?? \"md\";\n  const cardBordered = field.ui?.card?.bordered ?? true;\n\n  const isCardVariant = variant === \"card\";\n  const optionCount = Math.min(\n    Array.isArray(field.options) ? field.options.length : 3,\n    6,\n  );\n\n  const gridClasses = cn(\n    \"grid gap-2\",\n    direction === \"horizontal\" && columns === 1\n      ? \"grid-flow-col auto-cols-fr\"\n      : undefined,\n    columns === 2 && \"sm:grid-cols-2\",\n    columns === 3 && \"sm:grid-cols-2 md:grid-cols-3\",\n    columns === 4 && \"sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4\",\n  );\n\n  return (\n    <div className={cn(\"flex flex-col gap-2\", field.style?.className)}>\n      {label && <div className=\"h-4 w-32 animate-pulse rounded bg-muted\" />}\n      <div className={gridClasses}>\n        {Array.from({ length: optionCount }).map((_, i) =>\n          isCardVariant ? (\n            <div\n              key={i}\n              className={cn(\n                \"rounded-lg border animate-pulse\",\n                cardBordered && \"border-border\",\n                cardSizeClasses[cardSize],\n              )}\n            >\n              <div className=\"h-4 w-3/4 rounded bg-muted\" />\n            </div>\n          ) : (\n            <div key={i} className=\"flex items-center gap-2.5\">\n              <div className=\"size-4 rounded bg-muted animate-pulse\" />\n              <div className=\"h-4 w-24 rounded bg-muted animate-pulse\" />\n            </div>\n          ),\n        )}\n      </div>\n      {field.description && (\n        <div className=\"h-3 w-48 animate-pulse rounded bg-muted\" />\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/buzzform/fields/checkbox-group.tsx"
    }
  ],
  "type": "registry:ui"
}