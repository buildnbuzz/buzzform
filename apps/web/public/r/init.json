{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "init",
  "title": "BuzzForm",
  "description": "Core BuzzForm components including Form, FormFields, FormSubmit, FormReset, and field rendering system. Requires setting up a provider - see documentation.",
  "dependencies": [
    "@buildnbuzz/buzzform"
  ],
  "registryDependencies": [
    "button",
    "field"
  ],
  "files": [
    {
      "path": "registry/base/form.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport type {\r\n  Field,\r\n  FormAdapter,\r\n  UseFormOptions,\r\n} from \"@buildnbuzz/buzzform\";\r\nimport { useForm } from \"@buildnbuzz/buzzform\";\r\n\r\nimport {\r\n  RenderFields,\r\n  FieldRenderer,\r\n  type FieldRegistry,\r\n} from \"@/components/buzzform/fields/render\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { FieldGroup } from \"@/components/ui/field\";\r\n\r\n// Types\r\ntype ButtonProps = React.ComponentProps<typeof Button>;\r\n\r\n// Context\r\ninterface FormContextValue<TData = Record<string, unknown>> {\r\n  form: FormAdapter<TData>;\r\n  fields: readonly Field[];\r\n  registry?: FieldRegistry;\r\n  disabled: boolean;\r\n  requireDirty: boolean;\r\n  disableIfInvalid: boolean;\r\n}\r\n\r\nconst FormContext = React.createContext<FormContextValue | null>(null);\r\n\r\nfunction useFormContext<TData = Record<string, unknown>>() {\r\n  const ctx = React.useContext(FormContext);\r\n  if (!ctx) throw new Error(\"useFormContext must be used within <Form>\");\r\n  return ctx as FormContextValue<TData>;\r\n}\r\n\r\n// Form\r\ninterface FormProps<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> extends UseFormOptions<TData> {\r\n  fields?: readonly Field[];\r\n  className?: string;\r\n  children?: React.ReactNode;\r\n  registry?: FieldRegistry;\r\n  disabled?: boolean;\r\n  requireDirty?: boolean;\r\n  disableIfInvalid?: boolean;\r\n  submitLabel?: string;\r\n  submitClassName?: string;\r\n  showSubmit?: boolean;\r\n}\r\n\r\nfunction Form<TData extends Record<string, unknown>>({\r\n  schema,\r\n  fields: explicitFields,\r\n  defaultValues,\r\n  onSubmit,\r\n  mode,\r\n  settings: explicitSettings,\r\n  adapter,\r\n  className,\r\n  children,\r\n  registry,\r\n  disabled = false,\r\n  requireDirty = false,\r\n  disableIfInvalid = false,\r\n  submitLabel,\r\n  submitClassName,\r\n  showSubmit = true,\r\n}: FormProps<TData>) {\r\n  const settings = React.useMemo(() => {\r\n    if (!explicitSettings && !requireDirty) return undefined;\r\n    return {\r\n      ...explicitSettings,\r\n      submitOnlyWhenDirty:\r\n        requireDirty || explicitSettings?.submitOnlyWhenDirty,\r\n    };\r\n  }, [explicitSettings, requireDirty]);\r\n\r\n  const form = useForm<TData>({\r\n    schema,\r\n    defaultValues,\r\n    onSubmit,\r\n    mode,\r\n    settings,\r\n    adapter,\r\n  });\r\n\r\n  const fields: readonly Field[] = React.useMemo(() => {\r\n    if (explicitFields) return explicitFields;\r\n    if (schema && \"fields\" in schema) return schema.fields as readonly Field[];\r\n    return [];\r\n  }, [explicitFields, schema]);\r\n\r\n  const contextValue = React.useMemo<FormContextValue<TData>>(\r\n    () => ({\r\n      form,\r\n      fields,\r\n      registry,\r\n      disabled,\r\n      requireDirty,\r\n      disableIfInvalid,\r\n    }),\r\n    [form, fields, registry, disabled, requireDirty, disableIfInvalid]\r\n  );\r\n\r\n  const content = children ?? (\r\n    <FormContent className={className}>\r\n      <FormFields />\r\n      {showSubmit && (\r\n        <FormSubmit className={submitClassName}>{submitLabel}</FormSubmit>\r\n      )}\r\n    </FormContent>\r\n  );\r\n\r\n  return (\r\n    <FormContext.Provider value={contextValue as FormContextValue}>\r\n      {content}\r\n    </FormContext.Provider>\r\n  );\r\n}\r\n\r\n// FormContent\r\nfunction FormContent({ className, ...props }: React.ComponentProps<\"form\">) {\r\n  const { form } = useFormContext();\r\n  return (\r\n    <form\r\n      data-slot=\"form-content\"\r\n      onSubmit={form.handleSubmit}\r\n      className={cn(\"space-y-4\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n// FormFields\r\nfunction FormFields({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  const { fields, form, registry } = useFormContext();\r\n  return (\r\n    <FieldGroup\r\n      data-slot=\"field-group\"\r\n      className={cn(\"gap-2\", className)}\r\n      {...props}\r\n    >\r\n      <RenderFields fields={fields} form={form} registry={registry} />\r\n    </FieldGroup>\r\n  );\r\n}\r\n\r\n// FormField\r\nfunction FormField({\r\n  name,\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<\"div\"> & { name: string }) {\r\n  const { fields, form, registry } = useFormContext();\r\n  const field = fields.find((f) => \"name\" in f && f.name === name);\r\n\r\n  if (!field) {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      console.warn(`FormField: Field \"${name}\" not found in schema.`);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div data-slot=\"form-field\" className={className} {...props}>\r\n      <FieldRenderer\r\n        field={field}\r\n        path={name}\r\n        form={form}\r\n        registry={registry}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\ntype FormActionProps = ButtonProps;\r\n\r\nfunction FormAction({\r\n  children,\r\n  disabled: propDisabled,\r\n  ...props\r\n}: FormActionProps) {\r\n  const { form, disabled: formDisabled } = useFormContext();\r\n  const { isSubmitting, isLoading } = form.formState;\r\n\r\n  return (\r\n    <Button\r\n      disabled={propDisabled || formDisabled || isSubmitting || isLoading}\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Button>\r\n  );\r\n}\r\n\r\ntype FormSubmitProps = Omit<ButtonProps, \"disabled\"> & {\r\n  disabled?: boolean;\r\n  submittingText?: string;\r\n};\r\n\r\nfunction FormSubmit({\r\n  children,\r\n  className,\r\n  disabled: propDisabled,\r\n  variant,\r\n  size,\r\n  submittingText = \"Submitting...\",\r\n  ...props\r\n}: FormSubmitProps) {\r\n  const {\r\n    form,\r\n    disabled: formDisabled,\r\n    requireDirty,\r\n    disableIfInvalid,\r\n  } = useFormContext();\r\n  const { isSubmitting, isLoading, isDirty, isValid } = form.formState;\r\n\r\n  const isDisabled =\r\n    propDisabled ||\r\n    formDisabled ||\r\n    isSubmitting ||\r\n    isLoading ||\r\n    (requireDirty && !isDirty) ||\r\n    (disableIfInvalid && !isValid);\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      data-slot=\"form-submit\"\r\n      disabled={isDisabled}\r\n      variant={variant}\r\n      size={size}\r\n      className={className}\r\n      {...props}\r\n    >\r\n      {isSubmitting ? submittingText : children || \"Submit\"}\r\n    </Button>\r\n  );\r\n}\r\n\r\ntype FormResetProps = Omit<ButtonProps, \"disabled\" | \"onClick\"> & {\r\n  disabled?: boolean;\r\n};\r\n\r\nfunction FormReset({\r\n  children,\r\n  className,\r\n  disabled: propDisabled,\r\n  variant = \"outline\",\r\n  size,\r\n  ...props\r\n}: FormResetProps) {\r\n  const { form, disabled: formDisabled } = useFormContext();\r\n  const { isSubmitting, isDirty } = form.formState;\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"form-reset\"\r\n      variant={variant}\r\n      size={size}\r\n      onClick={() => form.reset()}\r\n      disabled={propDisabled || formDisabled || isSubmitting || !isDirty}\r\n      className={className}\r\n      {...props}\r\n    >\r\n      {children || \"Reset\"}\r\n    </Button>\r\n  );\r\n}\r\n\r\n// FormActions\r\nfunction FormActions({\r\n  className,\r\n  align = \"end\",\r\n  ...props\r\n}: React.ComponentProps<\"div\"> & {\r\n  align?: \"start\" | \"center\" | \"end\" | \"between\";\r\n}) {\r\n  return (\r\n    <div\r\n      data-slot=\"form-actions\"\r\n      data-align={align}\r\n      className={cn(\r\n        \"flex gap-2\",\r\n        align === \"start\" && \"justify-start\",\r\n        align === \"center\" && \"justify-center\",\r\n        align === \"end\" && \"justify-end\",\r\n        align === \"between\" && \"justify-between\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n// FormMessage\r\nfunction FormMessage({\r\n  className,\r\n  children,\r\n  ...props\r\n}: React.ComponentProps<\"div\">) {\r\n  const { form } = useFormContext();\r\n  const rootError = form.formState.errors[\"\"] || form.formState.errors[\"root\"];\r\n  const message =\r\n    children || (typeof rootError === \"string\" ? rootError : null);\r\n\r\n  if (!message) return null;\r\n\r\n  return (\r\n    <div\r\n      role=\"alert\"\r\n      data-slot=\"form-message\"\r\n      className={cn(\r\n        \"rounded-md bg-destructive/10 px-3 py-2 text-sm text-destructive\",\r\n        className\r\n      )}\r\n      {...props}\r\n    >\r\n      {message}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Exports\r\nexport {\r\n  Form,\r\n  FormContent,\r\n  FormFields,\r\n  FormField,\r\n  FormSubmit,\r\n  FormReset,\r\n  FormAction,\r\n  FormActions,\r\n  FormMessage,\r\n  useFormContext,\r\n  type FormProps,\r\n};\r\n",
      "type": "registry:component",
      "target": "components/buzzform/form.tsx"
    },
    {
      "path": "registry/base/fields/render.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport type {\n  Field,\n  FormAdapter,\n  DataField,\n  FieldInputProps,\n  FieldComponentProps,\n  FieldType,\n} from \"@buildnbuzz/buzzform\";\nimport { generateFieldId, getNestedValue } from \"@buildnbuzz/buzzform\";\n\nimport type { ComponentType } from \"react\";\nimport {\n  TextField,\n  TextFieldSkeleton,\n} from \"@/components/buzzform/fields/text\";\nimport {\n  TextareaField,\n  TextareaFieldSkeleton,\n} from \"@/components/buzzform/fields/textarea\";\nimport {\n  CheckboxField,\n  CheckboxFieldSkeleton,\n} from \"@/components/buzzform/fields/checkbox\";\nimport {\n  CheckboxGroupField,\n  CheckboxGroupFieldSkeleton,\n} from \"@/components/buzzform/fields/checkbox-group\";\nimport {\n  PasswordField,\n  PasswordFieldSkeleton,\n} from \"@/components/buzzform/fields/password\";\nimport {\n  SwitchField,\n  SwitchFieldSkeleton,\n} from \"@/components/buzzform/fields/switch\";\nimport {\n  RadioField,\n  RadioFieldSkeleton,\n} from \"@/components/buzzform/fields/radio\";\nimport {\n  NumberField,\n  NumberFieldSkeleton,\n} from \"@/components/buzzform/fields/number\";\nimport {\n  TagsField,\n  TagsFieldSkeleton,\n} from \"@/components/buzzform/fields/tags\";\nimport {\n  DateField,\n  DateFieldSkeleton,\n} from \"@/components/buzzform/fields/date\";\nimport {\n  SelectField,\n  SelectFieldSkeleton,\n} from \"@/components/buzzform/fields/select\";\nimport {\n  UploadField,\n  UploadFieldSkeleton,\n} from \"@/components/buzzform/fields/upload\";\nimport { RowField, RowFieldSkeleton } from \"@/components/buzzform/fields/row\";\nimport {\n  GroupField,\n  GroupFieldSkeleton,\n} from \"@/components/buzzform/fields/group\";\nimport {\n  CollapsibleField,\n  CollapsibleFieldSkeleton,\n} from \"@/components/buzzform/fields/collapsible\";\nimport {\n  TabsField,\n  TabsFieldSkeleton,\n} from \"@/components/buzzform/fields/tabs\";\nimport {\n  ArrayField,\n  ArrayFieldSkeleton,\n} from \"@/components/buzzform/fields/array\";\n\nexport interface FieldRendererComponentProps {\n  field: Field;\n  path: string;\n  form: FormAdapter;\n  autoFocus?: boolean;\n  formValues: Record<string, unknown>;\n  siblingData: Record<string, unknown>;\n  // Computed props\n  fieldId: string;\n  label: React.ReactNode | null;\n  isDisabled: boolean;\n  isReadOnly: boolean;\n  error?: string;\n}\n\nexport interface FieldRegistryEntry {\n  kind: \"data\" | \"layout\";\n  renderer: ComponentType<FieldRendererComponentProps>;\n  skeleton?: ComponentType<{ field: Field }>;\n}\n\nexport type FieldRegistry = Partial<Record<FieldType, FieldRegistryEntry>>;\n\nexport function createFieldRegistry(entries: FieldRegistry): FieldRegistry {\n  return entries;\n}\n\nexport function mergeRegistries(...registries: FieldRegistry[]): FieldRegistry {\n  return Object.assign({}, ...registries);\n}\n\nexport const defaultFieldRegistry: FieldRegistry = createFieldRegistry({\n  text: {\n    kind: \"data\",\n    renderer: TextField as ComponentType<FieldRendererComponentProps>,\n    skeleton: TextFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  email: {\n    kind: \"data\",\n    renderer: TextField as ComponentType<FieldRendererComponentProps>,\n    skeleton: TextFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  textarea: {\n    kind: \"data\",\n    renderer: TextareaField as ComponentType<FieldRendererComponentProps>,\n    skeleton: TextareaFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  checkbox: {\n    kind: \"data\",\n    renderer: CheckboxField as ComponentType<FieldRendererComponentProps>,\n    skeleton: CheckboxFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  \"checkbox-group\": {\n    kind: \"data\",\n    renderer: CheckboxGroupField as ComponentType<FieldRendererComponentProps>,\n    skeleton: CheckboxGroupFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  password: {\n    kind: \"data\",\n    renderer: PasswordField as ComponentType<FieldRendererComponentProps>,\n    skeleton: PasswordFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  switch: {\n    kind: \"data\",\n    renderer: SwitchField as ComponentType<FieldRendererComponentProps>,\n    skeleton: SwitchFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  radio: {\n    kind: \"data\",\n    renderer: RadioField as ComponentType<FieldRendererComponentProps>,\n    skeleton: RadioFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  number: {\n    kind: \"data\",\n    renderer: NumberField as ComponentType<FieldRendererComponentProps>,\n    skeleton: NumberFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  tags: {\n    kind: \"data\",\n    renderer: TagsField as ComponentType<FieldRendererComponentProps>,\n    skeleton: TagsFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  date: {\n    kind: \"data\",\n    renderer: DateField as ComponentType<FieldRendererComponentProps>,\n    skeleton: DateFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  datetime: {\n    kind: \"data\",\n    renderer: DateField as ComponentType<FieldRendererComponentProps>,\n    skeleton: DateFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  select: {\n    kind: \"data\",\n    renderer: SelectField as ComponentType<FieldRendererComponentProps>,\n    skeleton: SelectFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  upload: {\n    kind: \"data\",\n    renderer: UploadField as ComponentType<FieldRendererComponentProps>,\n    skeleton: UploadFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  row: {\n    kind: \"layout\",\n    renderer: RowField as ComponentType<FieldRendererComponentProps>,\n    skeleton: RowFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  group: {\n    kind: \"data\",\n    renderer: GroupField as ComponentType<FieldRendererComponentProps>,\n    skeleton: GroupFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  collapsible: {\n    kind: \"layout\",\n    renderer: CollapsibleField as ComponentType<FieldRendererComponentProps>,\n    skeleton: CollapsibleFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  tabs: {\n    kind: \"layout\",\n    renderer: TabsField as ComponentType<FieldRendererComponentProps>,\n    skeleton: TabsFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n  array: {\n    kind: \"data\",\n    renderer: ArrayField as ComponentType<FieldRendererComponentProps>,\n    skeleton: ArrayFieldSkeleton as ComponentType<{ field: Field }>,\n  },\n});\n\n// Types\nexport interface FieldRendererProps {\n  field: Field;\n  path: string;\n  form: FormAdapter;\n  registry?: FieldRegistry;\n  isFirstField?: boolean;\n}\n\nexport interface RenderFieldsProps {\n  fields: readonly Field[];\n  form: FormAdapter;\n  basePath?: string;\n  registry?: FieldRegistry;\n}\n\n// Helpers\nfunction isDataField(field: Field): field is DataField {\n  return \"name\" in field && field.name !== undefined;\n}\n\nfunction getSiblingData(\n  formValues: Record<string, unknown>,\n  path: string,\n): Record<string, unknown> {\n  const pathParts = path.split(\".\");\n  const parentParts = pathParts.slice(0, -1);\n  if (parentParts.length === 0) return formValues;\n  const parent = getNestedValue(formValues, parentParts.join(\".\"));\n  return (parent as Record<string, unknown>) ?? formValues;\n}\n\nfunction getErrorMessage(\n  errors: Record<string, string | string[] | undefined>,\n  path: string,\n): string | undefined {\n  const error = errors[path];\n  if (typeof error === \"string\") return error;\n  if (Array.isArray(error)) return error[0];\n  return undefined;\n}\n\n// Default skeleton\nfunction DefaultFieldSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      <div className=\"h-4 w-24 animate-pulse rounded bg-muted\" />\n      <div className=\"h-8 w-full animate-pulse rounded-lg bg-muted\" />\n    </div>\n  );\n}\n\n// Custom component renderer (field.component)\nfunction CustomComponentRenderer({\n  field,\n  path,\n  form,\n  autoFocus,\n  fieldId,\n  isDisabled,\n  isReadOnly,\n  error,\n}: FieldRendererComponentProps & { field: DataField }) {\n  const CustomComponent = field.component as React.ComponentType<\n    FieldComponentProps<unknown, DataField>\n  >;\n  const value = form.watch(path);\n  return (\n    <CustomComponent\n      field={field}\n      path={path}\n      id={fieldId}\n      form={form}\n      value={value}\n      onChange={(val: unknown) =>\n        form.setValue(path, val, { shouldDirty: true })\n      }\n      onBlur={() => {\n        form.onBlur?.(path);\n      }}\n      disabled={isDisabled}\n      readOnly={isReadOnly}\n      error={error}\n      autoFocus={autoFocus}\n    />\n  );\n}\n\n// Custom input renderer (field.input)\nfunction CustomInputRenderer({\n  field,\n  path,\n  form,\n  autoFocus,\n  fieldId,\n  label,\n  isDisabled,\n  isReadOnly,\n  error,\n}: FieldRendererComponentProps & { field: DataField }) {\n  const value = form.watch(path);\n  const inputProps: FieldInputProps = {\n    field,\n    path,\n    id: fieldId,\n    name: field.name,\n    value,\n    onChange: (val: unknown) => form.setValue(path, val, { shouldDirty: true }),\n    onBlur: () => {\n      form.onBlur?.(path);\n    },\n    disabled: isDisabled,\n    readOnly: isReadOnly,\n    error: error,\n    autoFocus,\n    validation: {\n      isChecking: form.formState.isValidating,\n      isValid: !error,\n      message: error,\n    },\n  };\n\n  const CustomInput = field.input;\n  const inputElement =\n    typeof CustomInput === \"function\" && !React.isValidElement(CustomInput)\n      ? (CustomInput as (props: FieldInputProps) => React.ReactNode)(inputProps)\n      : React.createElement(\n          CustomInput as React.ComponentType<FieldInputProps>,\n          inputProps,\n        );\n\n  return (\n    <div\n      className={field.style?.className}\n      style={field.style?.width ? { width: field.style.width } : undefined}\n    >\n      {label && (\n        <label htmlFor={fieldId} className=\"block text-sm font-medium mb-1.5\">\n          {label}\n          {field.required && <span className=\"text-destructive ml-0.5\">*</span>}\n        </label>\n      )}\n\n      <div\n        ref={(el) => {\n          if (autoFocus && el) {\n            const focusable = el.querySelector<HTMLElement>(\n              'input, textarea, select, button, [tabindex]:not([tabindex=\"-1\"])',\n            );\n            focusable?.focus();\n          }\n        }}\n      >\n        {inputElement}\n      </div>\n\n      {field.description && (\n        <p className=\"text-sm text-muted-foreground mt-1.5\">\n          {field.description}\n        </p>\n      )}\n\n      {error && (\n        <p className=\"text-sm text-destructive mt-1.5\" role=\"alert\">\n          {error}\n        </p>\n      )}\n    </div>\n  );\n}\n\n// FieldRenderer\nexport function FieldRenderer({\n  field,\n  path,\n  form,\n  registry = defaultFieldRegistry,\n  isFirstField = false,\n}: FieldRendererProps) {\n  const formValues = form.getValues();\n  const siblingData = getSiblingData(formValues, path);\n\n  const isHidden = (() => {\n    if (!isDataField(field)) return false;\n    if (typeof field.hidden === \"function\")\n      return field.hidden(formValues, siblingData);\n    return field.hidden ?? false;\n  })();\n\n  const isConditionMet = (() => {\n    if (!isDataField(field)) return true;\n    if (field.condition) {\n      return field.condition(formValues, siblingData, {\n        operation: \"update\",\n        path: path.split(\".\"),\n      });\n    }\n    return true;\n  })();\n\n  // Derived properties calculation\n  const fieldId =\n    isDataField(field) && field.id ? field.id : generateFieldId(path);\n\n  const label = (() => {\n    // Layout fields (like collapsible, tabs) have label but no name\n    if (\"label\" in field && field.label !== false) {\n      return field.label ?? null;\n    }\n    // Data fields use label or fallback to name\n    if (isDataField(field) && field.label !== false) {\n      return field.label ?? field.name ?? null;\n    }\n    return null;\n  })();\n\n  const isDisabled = (() => {\n    if (!isDataField(field)) return false;\n    const disabled =\n      typeof field.disabled === \"function\"\n        ? field.disabled(formValues, siblingData)\n        : (field.disabled ?? false);\n    return disabled || form.formState.isSubmitting;\n  })();\n\n  const isReadOnly = (() => {\n    if (!isDataField(field)) return false;\n    return typeof field.readOnly === \"function\"\n      ? field.readOnly(formValues, siblingData)\n      : (field.readOnly ?? false);\n  })();\n\n  const error = getErrorMessage(form.formState.errors, path);\n\n  const shouldAutoFocus = (() => {\n    if (!isDataField(field)) return false;\n    return (\n      isFirstField && form.settings?.autoFocus && !isDisabled && !isReadOnly\n    );\n  })();\n\n  if (isHidden || !isConditionMet) return null;\n\n  const registryEntry = registry[field.type];\n\n  if (form.formState.isLoading) {\n    if (registryEntry?.skeleton) {\n      const Skeleton = registryEntry.skeleton;\n      return <Skeleton field={field} />;\n    }\n    return <DefaultFieldSkeleton />;\n  }\n\n  if (isDataField(field) && field.component) {\n    return (\n      <CustomComponentRenderer\n        field={field}\n        path={path}\n        form={form}\n        formValues={formValues}\n        siblingData={siblingData}\n        autoFocus={shouldAutoFocus}\n        fieldId={fieldId}\n        label={label}\n        isDisabled={isDisabled}\n        isReadOnly={isReadOnly}\n        error={error}\n      />\n    );\n  }\n\n  if (isDataField(field) && field.input) {\n    return (\n      <CustomInputRenderer\n        field={field}\n        path={path}\n        form={form}\n        formValues={formValues}\n        siblingData={siblingData}\n        autoFocus={shouldAutoFocus}\n        fieldId={fieldId}\n        label={label}\n        isDisabled={isDisabled}\n        isReadOnly={isReadOnly}\n        error={error}\n      />\n    );\n  }\n\n  if (!registryEntry) {\n    return (\n      <div className=\"rounded border border-destructive bg-destructive/10 p-2 text-xs text-destructive\">\n        Unsupported field type: <code className=\"font-mono\">{field.type}</code>\n      </div>\n    );\n  }\n\n  const Renderer = registryEntry.renderer;\n  return (\n    <Renderer\n      field={field}\n      path={path}\n      form={form}\n      autoFocus={shouldAutoFocus}\n      formValues={formValues}\n      siblingData={siblingData}\n      fieldId={fieldId}\n      label={label}\n      isDisabled={isDisabled}\n      isReadOnly={isReadOnly}\n      error={error}\n    />\n  );\n}\n\n// RenderFields\nexport function RenderFields({\n  fields,\n  form,\n  basePath = \"\",\n  registry,\n}: RenderFieldsProps) {\n  let firstFieldName: string | null = null;\n  for (const field of fields) {\n    if (\"name\" in field && field.name) {\n      firstFieldName = field.name;\n      break;\n    }\n  }\n\n  return (\n    <>\n      {fields.map((field, index) => {\n        const hasName = \"name\" in field && field.name;\n        const fieldPath = hasName\n          ? basePath\n            ? `${basePath}.${field.name}`\n            : field.name\n          : basePath;\n\n        const key = hasName ? field.name : `${field.type}-${index}`;\n        const isFirstField = !!(hasName && field.name === firstFieldName);\n\n        return (\n          <FieldRenderer\n            key={key}\n            field={field}\n            path={fieldPath}\n            form={form}\n            registry={registry}\n            isFirstField={isFirstField}\n          />\n        );\n      })}\n    </>\n  );\n}\n\nexport default FieldRenderer;\n",
      "type": "registry:component",
      "target": "components/buzzform/fields/render.tsx"
    }
  ],
  "type": "registry:ui"
}